# tasks_for_itfb

## Предварительные шаги запуска скриптов 

1. Активация виртуального окружения:

   Для активации виртуального окружения воспользуйтесь командой (для Linux):

    >source venv/bin/activate

   для Windows команда будет выглядеть так:

    >venv\Scripts\activate.bat

2. Выполняем установку зависимостей:
    >pip install -r requirements.txt

3. запускаем то задание, которое интересует


## Алгоритмы

### Описание
1. Реализовать простой алгоритм сортировки массива (RAM):
для (каждого i от 0 до N-1)
для (каждого k от i+1 до N)
если(элемент[k] < элемент [i]) {
//поменять элементы местами, можно использовать временную переменную
}

2. Реализовать инверсию линейного списка содержащего элементы простого типа с минимальным
использованием дополнительного переменных/структур данных


3. Реализовать алгоритм. Дан массив целочисленных значений, необходимо вернуть индексы двух
элементов, сумма которых равна целевому значению. Можно предположить, что решение всегда
существует и оно единственно. Один элемент два раза не используется.


4. Реализовать алгоритм. Дана строка A, которая представляет из себя камни, являющиеся алмазами,
 и строка K, в которой камни.
Каждый символ из строки К - это камень. Задача: найти все  камни в строке К, которые одновременно
являются и алмазами и камнями. Символы в строке А не повторяются. Алфавит строк А и К = {от А до я}.
Символы в строке
чувствительны к регистру (камень "А" != камню "а")
Пример 1: Вход: А = "aA", К = "аAAбббб"
Вывод: 3
Пример 2: Ввод: А = "я", К = "ЯЯ"
Вывод: 0
Примечание :
• А и К - строки, длина которых не более 50 символов.
• Символы в А не повторяются.

5. Реализовать алгоритм:
Дана строка содержащая цифры от 2 до 9 (включительно). Вернуть все возможные комбинации пар
букв, которые можно получить для данных цифр.
Маппинг цифр на буквы соответствует клавиатуре телефона (2 - абвг, 3-дежз и т.п.). Единица не
соответствует никакой букве.


### Запуск

>python алгоритмы/task_*.py desired_line 

где desired_line - строка аргументов(если нужны),
а * - номер версии/задачи файла


## Практические задачи

### Задача 1.Парсинг данных из веб.Описание

Необходимо скачать страницу https://dfedorov.spb.ru/python3/ya_forecast.html , разобрать её и сгенерировать файл с разделителем следующего формата (имя файла weather.csv):

weekday;temperature;speed;probability

Используемые пакеты: requests, BeautifulSoup, csv, регулярные выражения

### Запуск

>python Parser\main.py

### Задача 3.Работа с данными.Описание

Идём на https://data.mos.ru/ скачиваем любой интересующий вас (и подходящий по смыслу задачи)  датасет (json,csv,xml), пишем код импорта по внутреннюю структуру (словарь, список), создаём sqllite3 БД, прогружаем туда данные (список колонок как в исходном файле). Пишем 2-3 запроса с использованием агрегативных функция для вывода общей информации о датасете (кол-во строк, кол-во уникальных значений в колонках и т.п.), распределение количества по записей по какой-либо неуникальной колонке.  Из полученных агрегированных данных строим столбчатую диаграмму в матплотлибе (например для датасета про вызовы пожарных - распределение кол-ва вызовов по годам). 

### Запуск

>python Data_sql_graph\main.py



### Задача 4.Работа с данными, с помощью pandas/jupyter.Описание
Пытаемся проделать те же шаги, что и в задаче 3, только с помощью pandas и jupyter.

### Запуск

Запускаем юпитер

>jupyter notebook

В открывшемся окне ищем файл _main.ipynb_ в папке Data+sql+graph+pand, открываем и смотрим все шаги

### Задача 5.Классификация эмоциональной окраски отзывов.Описание

Необходимо разделить отзывы на положительные и отрицательные. В
случае невозможности классификации ставить 'undef'.
Файл с отзывами texts_opinions.txt в директории.
После классификации отзывов мы можем сверить наш результат
с «правильной» классификацией texts_ratings.txt, которую выставляли
сами пользователи, когда писали эти отзывы.
Файл texts_ratings.txt находится вместе с texts_opinions.txt 

### Запуск

>python Reviews_classification/main.py

